-- liquibase formatted sql

-- changeset ldv236:171
-- DDL команда на создание представления - отдельной таблицы, но которая не сама содержит данные, а агрегирует из других
CREATE VIEW pass_in_out_view AS
-- CTE - common table expression - относительно новый аналог подзапроса, как, например, селект из кар-бренд в инсерте:
-- INSERT INTO cars (license_plate, brand_id) VALUES ('А777АА77', (select id from car_brand where brand = 'Toyota');
-- Начинается с ключевого слова WITH; как бы создает временную таблицу, которую мы потом используем в основном запросе.
-- Здесь сопоставляется время въезда и выезда по каждому пропуску (если по нему вообще есть пересечения):
WITH cross_pairs AS
    -- внутри еще два вложенных CTE: для въездов (см. where), потом для выездов
    (WITH InRanked AS (
        SELECT pass_id, local_date_time as time,
        -- оконная функция - продвинутая хрень в sql, обычно нужна для аналитики всякой;
        -- ключевое слово - OVER, слева от него оператор, справа - собственно, окно, над которым оператор и трудится;
        -- оконные функции добавляют новый столбец с результатом работы оператора (как агрегатный оператор на анаболиках);
        -- конкретно здесь в новый столбец помещается номер строки в окне,
        -- а окно - это все строки из crossings с одинаковым pass_id, отсортированные по времени пересечения;
        -- этот номер строки потом нужен будет для сопоставления
        ROW_NUMBER() OVER (PARTITION BY pass_id ORDER BY local_date_time) as rn
        FROM crossings
        WHERE direction = 'IN'), -- несколько CTE можно создавать через запятую, WITH повторять не надо
    -- так что вот второй вложенный CTE, такой же как первый, но для выездов
    OutRanked AS (
        SELECT pass_id, local_date_time as time,
        ROW_NUMBER() OVER (PARTITION BY pass_id ORDER BY local_date_time) as rn
        FROM crossings
        WHERE direction = 'OUT')

-- здесь мы еще находимся внутри большого CTE (cross_pairs), но уже можем использовать CTE InRanked и OutRanked:
-- им присваиваются псевдонимы (алиасы) - их можно через AS объявлять, и можно и без - просто InRanked i, OutRanked o;
-- COALESCE(i.pass_id, o.pass_id) - выбирает из параметров в скобках первое ненулевое (это надо потому что мы не знаем,
-- по какому пропуску есть оба пересечения, по какому только въезд, по какому только выезд, а pass_id тут одинаковый,
-- т.к. ниже мы по нему джойним InRanked и OutRanked).
SELECT COALESCE(i.pass_id, o.pass_id) as pass_id,
       i.time as in_time, o.time as out_time
-- Джойн именно фулл всё по той же причине - у пересечения может не быть пары, и тогда строка все равно будет,
-- но с одним пустым значением
FROM InRanked i
       FULL JOIN OutRanked o ON i.pass_id = o.pass_id
       -- ключевой момент - джойним также по номерам строк (джойн по двум полям получается), которые сделала оконная функция!
       -- т.е. ПЕРВЫЙ въезд по пропуску соединяется с ПЕРВЫМ выездом, второй со вторым и тд
       -- (столбец оконной функции в CTE назван "rn", см. выше)
       AND i.rn = o.rn)

-- всё, итоговый CTE сформирован - у нас есть пары въезд-выезд,
-- в которых всего три колонки - pass_id, in_time, out_time;
-- так что можем по pass_id сджойнить нужные данные из других таблиц
SELECT p.dtype, p.comment as pass_comment, t.name as terr_name,
       p.type_time as pass_time_type, p.status as pass_status,
       c.license_plate as car, v.full_name as visitor,
       cpr.in_time, cpr.out_time, p.id as pass_id,
       p.territory_id, p.user_id
-- начал с таблицы пропусков, как пересекающейся со всеми остальными, но вообще порядок может быть разный
FROM passes p
         -- джойним с территориями, но см. в селекте - из территорий берется только t.name
         JOIN territories t on p.territory_id = t.id
         -- джойн именно лефт, потому что в каких-то строках только кар, в каких-то только визитор -
         -- если написать простой джойн, вообще ни одна строка не подойдет под условие.
         -- также берется только по одному полю из машины и из визитора
         LEFT JOIN cars c on p.car_id = c.id
         LEFT JOIN visitors v on p.visitor_id = v.id
         -- ну и соединяем с самими спаренными пересечениями
         JOIN cross_pairs cpr on cpr.pass_id = p.id;
-- в целом можно было бы сделать проще, если не учитывать риски отсутствия пары для какого-то пересечения,
-- а если бы у нас были только разовые пропуска (по каждому только 1 въезд и 1 выезд), то вообще простой был бы запрос
